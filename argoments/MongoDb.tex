\chapter{MongoDb}

\section{Caratteristiche}

MongoDb e' uno dei piu' diffusi database non relazionali orientato ai documenti, di tipo NoSQL,  utilizza documenti in un formato JSON al posto delle tipiche tabelle 
dei sistemi relazionali. Piu' precisamente MongoDb utilizza i BSON ossia JSON binari per rappresentare strutture dati semplici e array associativi (oggetti in MongoDb),
un BSON contiene una lista ordinata di elementi appartenenti ai seguenti tipi:

\begin{list}{}{}
    \item stringhe
    \item interi (32 o 64 bit)
    \item double (numeri a virgola mobile a 64 bit, standard IEEE 754)
    \item date (numeri interi in millisecondi dal'epoca Unix come riferimento, 1ยบ gennaio 1970)
    \item byte array (dati binari)
    \item booleani (true e false)
    \item NULL
    \item oggetto BSON
    \item array BSON
    \item espressioni regolari
    \item codice JavaScript
\end{list}

\section{Organizzazione dei dati}

\subsection{Creazione collezioni}

Per poter originare i set di dati sui quali lavoriamo siamo partiti da 2 enormi file JSON generati al paragrafo ??????????? //TODO riguarda qua //
contenenti POST (A) e COMMENTI(B). Il paramentro \$out posto dopo la query ha creato una collezione a tuttli gli effetti sulla quale poter eseguire le query
all'interno della rete del container.

\subsubsection{Referencing}

Il referencing di A in B si ottiene facilmente proiettando gli attributi della collezione B, dato che contiene al suo interno la foreign Key di A.

\begin{verbatim}
db.B.aggregate([
  {
    $project: {
      "_id" : "$BK",
      "BK" : "$BK",
      "AK" : "$FAK",
      "B1" : "$B1",   
      "B2" : "$B2",
      "B3" : "$B3",
      "B4" : "$B4",
      "B5" : "$B5",
      "B6" : "$B6",
      "B7" : "$B7"
    }
  },{
  $out : "referencing_A_in_B"
}
])
\end{verbatim}

Il referencing di B in A invece richiede un join, un' operazione piu' onerosa per la quale ho dovuto passare il parametro allowDiskUse=true per poter utilizzare
a pieno la memoria della macchina e quindi eseguire il join trovando di fatto le chiavi e aggiungendole all'array B che arrivera' a contenere 10 chivi BK per ogni 
AK dato che il rapporto e' di 1:10. 

\begin{verbatim}
    
db.B.aggregate(
[
   {
      $group: {
        _id: {"AK" : "$FAK"}, "BK": {$addToSet : "$BK"}
      }
    },
    {
      $lookup: {
        from: 'Ap',
        localField: '_id.AK',
        foreignField: 'AK',
        as: 'AK'
      }
    },{
      $project : {"_id" : 0,"BK.FAK" : 0}
    },{
    $unwind: {
      path: "$AK",
    }},{
      $project : {
      "_id" : "$AK.AK",
      "AK" : "$AK.AK",
      "A1" : "$AK.A1", 
      "A2" : "$AK.A2", 
      "A3" : "$AK.A3", 
      "A4" : "$AK.A4",
      "A5" : "$AK.A5",
      "A6" : "$AK.A6",
      "A7" : "$AK.A7",
       "B" : "$BK"} 
    },{
      $out : "referencing_B_in_A"
    }
  ],{allowDiskUse:true}
)
\end{verbatim}

\subsubsection{Embedding}
Per l'embedding di documenti ho dovuto sempre eseguire dei join ma e' stato fondamentale poter aggiungere un intero documento all'interno di un'array tramite il parametro
\verb|$$ROOT| che ha permesso un operazione molto piu'veloce e compatta.

Embedding di A in B 

\begin{verbatim}
db.B.aggregate(
  [
    {
      $lookup: {
        from: 'A',
        localField: 'FAK',
        foreignField: 'AK',
        as: 'A'
      }
    }
   ,{
     $project: {
       "FAK" : 0,
       "_id" : 0,
       "A._id" : 0
     }
   }
  ,{
    $project : {
      "_id" : "$BK",
      "B1" : 1,
      "B2" : 1,
      "B3" : 1,
      "B4" : 1,
      "B5" : 1,
      "B6" : 1,
      "B7" : 1,
      "A" : 1
    }
  }
  ,{
     $out : "embedding_A_in_B"
   }
  ]
)    
\end{verbatim}

Embedding di B in A

\begin{verbatim}
    db.B.aggregate(
  [
   {
      $group: {
        _id: {"AK" : "$FAK"}, "BK": {$addToSet : "$$ROOT"}
      }
    },
    {
      $lookup: {
        from: 'A',
        localField: '_id.AK',
        foreignField: 'AK',
        as: 'AK'
      }
    },{
      $project : {"_id" : 0,"BK.FAK" : 0}
    },{
    $unwind: {
      path: "$AK",
    }},{
      $project : {
        "_id" : "$AK.AK",
        "AK" : "$AK.AK", 
        "A1" : "$AK.A1", 
        "A2" : "$AK.A2", 
        "A3" : "$AK.A3", 
        "A4" : "$AK.A4",
        "A5" : "$AK.A5",
        "A6" : "$AK.A6",
        "A7" : "$AK.A7",
        "B" : "$BK"} 
    },{
        $project : { "A._id" : 0, "B._id" : 0}
    },{
        $out : "embedding_B_in_A"
   }
  ],{allowDiskUse:true}
)
\end{verbatim}

\subsection{Indici}

Gli indici per gli attributi sono stati creati attraverso uno script in JS che viene eseguito durante la creazione del container.

MongoDB utilizza, se non esplicitamente indicato, come strutture dati per gli indici dei B-tree. Dato che abbiamo scelto di adoperare l'embedding di interi documenti sono stati 
indicizzati anche gli attributi dei documenti "interni" sui quali saranno esegeuite delle query, anche sulle foreign del referencing sono stati costruiti indici.

\begin{lstlisting}[caption=making indexes, style=customJs]
// indexes
db.getCollection('embedding_A_in_B').createIndex({'B4': 1});
db.getCollection('embedding_A_in_B').createIndex({'B5': 1});
db.getCollection('embedding_A_in_B').createIndex({'B6': 1});

// nested indexes
db.getCollection('embedding_A_in_B').createIndex({'A.A4': 1});
db.getCollection('embedding_A_in_B').createIndex({'A.A5': 1});
db.getCollection('embedding_A_in_B').createIndex({'A.A6': 1});

// indexes
db.getCollection('embedding_B_in_A').createIndex({'A4': 1});
db.getCollection('embedding_B_in_A').createIndex({'A5': 1});
db.getCollection('embedding_B_in_A').createIndex({'A6': 1});

// nested indexes
db.getCollection('embedding_B_in_A').createIndex({'B.B4': 1});
db.getCollection('embedding_B_in_A').createIndex({'B.B5': 1});
db.getCollection('embedding_B_in_A').createIndex({'B.B6': 1});

//FK
db.getCollection('referencing_A_in_B').createIndex({'AK': 1});               

// indexes
db.getCollection('referencing_A_in_B').createIndex({'B4': 1});
db.getCollection('referencing_A_in_B').createIndex({'B5': 1});
db.getCollection('referencing_A_in_B').createIndex({'B6': 1});

//FK
db.getCollection('referencing_B_in_A').createIndex({'AK': 1});               

// indexes
db.getCollection('referencing_B_in_A').createIndex({'A4': 1});
db.getCollection('referencing_B_in_A').createIndex({'A5': 1});
db.getCollection('referencing_B_in_A').createIndex({'A6': 1});

// array indexes
db.getCollection('embedding_A_in_B').createIndex({'A': 1});
db.getCollection('embedding_B_in_A').createIndex({'B': 1});
\end{lstlisting}

% \lstinputlisting[caption=making indexes, style=customJs]
